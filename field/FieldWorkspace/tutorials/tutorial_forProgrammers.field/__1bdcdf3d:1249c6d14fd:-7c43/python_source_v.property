string>
# Field comes with a "keyframecreator" which wraps mutations to global variables inside special logic, enabling these side effects to be undone, reapplied and blended together

theVector = Vector3()

k = KeyFrameCreator()

_k = k.begin()
_k.theVector.x = 3
print theVector # prints (3, 0, 0)
# so far, no surprises. We've set _k.theVector.x=3 and gotten exactly what we'd get if we said theVector.x = 3

keyframe1 = k.end(_k)
print theVector    # prints (3, 0, 0)
# still no change there.

# but let's try this
theVector.x = 5
print theVector # prints (5, 0, 0)
keyframe1.apply()
print theVector # prints (3, 0, 0)

# the things we get back from 'end' can be _reapplied_

# let's make another one
_k = k.begin()
_k.theVector.x = 2
keyframe2 = k.end(_k)
print theVector    # prints (2, 0, 0)

# and now for the punchline:

(keyframe2*0.6666+keyframe1*0.3333).apply()
print theVector  # prints (2.33333, 0, 0)

# perhaps the real punchline is that this machinary works not because it has intimate knowledge of Vector3, it works because it has intimate knowledge of how Jython talks to Java Ñ that is, it works with your own Java classes.

# here's a more complex example
theVector = Vector3()

k = KeyFrameCreator()

_k = k.begin()
_k.theVector.x = 3
_k.theVector.add(Vector3(1,1,0))
keyframe1 = k.end(_k)

_k = k.begin()
_k.theVector.x = 2
_k.theVector.add(Vector3(1,1,0))
keyframe2 = k.end(_k)

(keyframe2*0.6666+keyframe1*0.3333).apply()
print theVector # prints (3.333333, 1.666667, 0.0)

# look at it closely Ñ here we've introduced two method calls to 'add'. While Field can't monitor all side effects (this is Python + Java, not Haskell) what it can do is blend the parameters for these methods, since it knows how to blend Vector3's 

# again, just like 'lazy things' you either think that this is a) really cool, b) terrifying, or c) incomphrensible. Any or all of these reactions are fine and you shouldn't worry.

# to print the 'contents' of a keyframe:
print keyframe2.changeSet
